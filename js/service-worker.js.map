{"mappings":"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","sources":["<anon>","src/js/service-worker.js"],"sourcesContent":["/**\n * Service Worker for Portfolio Caching and Performance\n * Implements caching strategies for static assets and offline support\n */ const CACHE_NAME = 'portfolio-v1.0.0';\nconst STATIC_CACHE = 'portfolio-static-v1.0.0';\nconst IMAGE_CACHE = 'portfolio-images-v1.0.0';\nconst FONT_CACHE = 'portfolio-fonts-v1.0.0';\n// Assets to cache immediately on install\nconst STATIC_ASSETS = [\n    '/',\n    '/index.html',\n    '/work.html',\n    '/contact.html',\n    '/css/main.css',\n    '/js/main.js',\n    '/js/enhanced-image-loader.js',\n    '/js/analytics/simple-analytics.js',\n    '/assets/favicons/favicon.ico',\n    '/assets/favicons/apple-icon.png'\n];\nself.addEventListener('install', (event)=>{\n    console.warn('[Service Worker] Installing');\n    event.waitUntil(caches.open(STATIC_CACHE).then((cache)=>{\n        console.warn('[Service Worker] Caching static assets');\n        return cache.addAll(STATIC_ASSETS);\n    }).then(()=>{\n        console.warn('[Service Worker] Installation complete');\n        return self.skipWaiting();\n    }).catch((error)=>{\n        console.error('[Service Worker] Installation failed:', error);\n    }));\n});\nself.addEventListener('activate', (event)=>{\n    console.warn('[Service Worker] Activating');\n    event.waitUntil(caches.keys().then((cacheNames)=>{\n        return Promise.all(cacheNames.map((cacheName)=>{\n            // Delete old caches\n            if (cacheName !== STATIC_CACHE && cacheName !== IMAGE_CACHE && cacheName !== FONT_CACHE && !cacheName.startsWith(CACHE_NAME)) {\n                console.warn('[Service Worker] Deleting old cache:', cacheName);\n                return caches.delete(cacheName);\n            }\n        }));\n    }).then(()=>{\n        console.warn('[Service Worker] Activation complete');\n        return self.clients.claim();\n    }));\n});\nself.addEventListener('fetch', (event)=>{\n    const { request } = event;\n    const url = new URL(request.url);\n    // Skip non-GET requests\n    if (request.method !== 'GET') return;\n    // Skip external requests (except allowed domains)\n    if (!url.origin.includes(self.location.origin) && !url.origin.includes('fonts.googleapis.com') && !url.origin.includes('fonts.gstatic.com') && !url.origin.includes('www.google-analytics.com') && !url.origin.includes('www.googletagmanager.com')) return;\n    // Handle different resource types\n    if (request.destination === 'document') // HTML pages - Network first\n    event.respondWith(handlePageRequest(request));\n    else if (request.destination === 'image' || url.pathname.match(/\\.(jpg|jpeg|png|gif|webp|svg)$/)) // Images - Cache first\n    event.respondWith(handleImageRequest(request));\n    else if (request.destination === 'font' || url.pathname.match(/\\.(woff|woff2|ttf|eot)$/)) // Fonts - Cache first\n    event.respondWith(handleFontRequest(request));\n    else if (request.destination === 'script' || request.destination === 'style') // Scripts and styles - Cache first\n    event.respondWith(handleStaticRequest(request));\n    else // Default - Network first\n    event.respondWith(fetch(request));\n});\n// Handle HTML page requests (Network First)\nasync function handlePageRequest(request) {\n    try {\n        // Try network first\n        const networkResponse = await fetch(request);\n        if (networkResponse.ok) {\n            // Update cache with fresh response\n            const cache = await caches.open(CACHE_NAME);\n            cache.put(request, networkResponse.clone());\n            return networkResponse;\n        }\n    } catch (error) {\n        console.warn('[Service Worker] Network failed, trying cache for:', request.url);\n    }\n    // Fallback to cache\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) return cachedResponse;\n    // Ultimate fallback - offline page\n    return caches.match('/offline.html') || new Response('<h1>Offline</h1><p>This page is not available offline.</p>', {\n        headers: {\n            'Content-Type': 'text/html'\n        }\n    });\n}\n// Handle image requests (Cache First)\nasync function handleImageRequest(request) {\n    // Check cache first\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) return cachedResponse;\n    try {\n        // Fetch from network\n        const networkResponse = await fetch(request);\n        if (networkResponse.ok) {\n            // Cache the response\n            const cache = await caches.open(IMAGE_CACHE);\n            cache.put(request, networkResponse.clone());\n        }\n        return networkResponse;\n    } catch (error) {\n        console.warn('[Service Worker] Image fetch failed:', request.url);\n        // Return a placeholder or cached version if available\n        return new Response('', {\n            status: 404\n        });\n    }\n}\n// Handle font requests (Cache First)\nasync function handleFontRequest(request) {\n    // Check cache first\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) return cachedResponse;\n    try {\n        // Fetch from network\n        const networkResponse = await fetch(request);\n        if (networkResponse.ok) {\n            // Cache the response\n            const cache = await caches.open(FONT_CACHE);\n            cache.put(request, networkResponse.clone());\n        }\n        return networkResponse;\n    } catch (error) {\n        console.warn('[Service Worker] Font fetch failed:', request.url);\n        return new Response('', {\n            status: 404\n        });\n    }\n}\n// Handle static asset requests (Cache First)\nasync function handleStaticRequest(request) {\n    // Check cache first\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) return cachedResponse;\n    try {\n        // Fetch from network\n        const networkResponse = await fetch(request);\n        if (networkResponse.ok) {\n            // Cache the response\n            const cache = await caches.open(STATIC_CACHE);\n            cache.put(request, networkResponse.clone());\n        }\n        return networkResponse;\n    } catch (error) {\n        console.warn('[Service Worker] Static asset fetch failed:', request.url);\n        return new Response('', {\n            status: 404\n        });\n    }\n}\n// Handle messages from the main thread\nself.addEventListener('message', (event)=>{\n    if (event.data && event.data.type === 'SKIP_WAITING') self.skipWaiting();\n});\n// Background sync for analytics (if supported)\nif ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) self.addEventListener('sync', (event)=>{\n    if (event.tag === 'background-sync-analytics') event.waitUntil(syncAnalyticsData());\n});\nfunction syncAnalyticsData() {\n    // Implementation for syncing queued analytics data\n    console.warn('[Service Worker] Syncing analytics data');\n// This would typically send queued analytics events to your server\n}\n\n//# sourceMappingURL=service-worker.js.map\n","/**\n * Service Worker for Portfolio Caching and Performance\n * Implements caching strategies for static assets and offline support\n */\n\nconst CACHE_NAME = 'portfolio-v1.0.0';\nconst STATIC_CACHE = 'portfolio-static-v1.0.0';\nconst IMAGE_CACHE = 'portfolio-images-v1.0.0';\nconst FONT_CACHE = 'portfolio-fonts-v1.0.0';\n\n// Assets to cache immediately on install\nconst STATIC_ASSETS = [\n  '/',\n  '/index.html',\n  '/work.html',\n  '/contact.html',\n  '/css/main.css',\n  '/js/main.js',\n  '/js/enhanced-image-loader.js',\n  '/js/analytics/simple-analytics.js',\n  '/assets/favicons/favicon.ico',\n  '/assets/favicons/apple-icon.png',\n];\n\nself.addEventListener('install', event => {\n  console.warn('[Service Worker] Installing');\n\n  event.waitUntil(\n    caches\n      .open(STATIC_CACHE)\n      .then(cache => {\n        console.warn('[Service Worker] Caching static assets');\n        return cache.addAll(STATIC_ASSETS);\n      })\n      .then(() => {\n        console.warn('[Service Worker] Installation complete');\n        return self.skipWaiting();\n      })\n      .catch(error => {\n        console.error('[Service Worker] Installation failed:', error);\n      })\n  );\n});\n\nself.addEventListener('activate', event => {\n  console.warn('[Service Worker] Activating');\n\n  event.waitUntil(\n    caches\n      .keys()\n      .then(cacheNames => {\n        return Promise.all(\n          cacheNames.map(cacheName => {\n            // Delete old caches\n            if (\n              cacheName !== STATIC_CACHE &&\n              cacheName !== IMAGE_CACHE &&\n              cacheName !== FONT_CACHE &&\n              !cacheName.startsWith(CACHE_NAME)\n            ) {\n              console.warn('[Service Worker] Deleting old cache:', cacheName);\n              return caches.delete(cacheName);\n            }\n          })\n        );\n      })\n      .then(() => {\n        console.warn('[Service Worker] Activation complete');\n        return self.clients.claim();\n      })\n  );\n});\n\nself.addEventListener('fetch', event => {\n  const { request } = event;\n  const url = new URL(request.url);\n\n  // Skip non-GET requests\n  if (request.method !== 'GET') {\n    return;\n  }\n\n  // Skip external requests (except allowed domains)\n  if (\n    !url.origin.includes(self.location.origin) &&\n    !url.origin.includes('fonts.googleapis.com') &&\n    !url.origin.includes('fonts.gstatic.com') &&\n    !url.origin.includes('www.google-analytics.com') &&\n    !url.origin.includes('www.googletagmanager.com')\n  ) {\n    return;\n  }\n\n  // Handle different resource types\n  if (request.destination === 'document') {\n    // HTML pages - Network first\n    event.respondWith(handlePageRequest(request));\n  } else if (\n    request.destination === 'image' ||\n    url.pathname.match(/\\.(jpg|jpeg|png|gif|webp|svg)$/)\n  ) {\n    // Images - Cache first\n    event.respondWith(handleImageRequest(request));\n  } else if (\n    request.destination === 'font' ||\n    url.pathname.match(/\\.(woff|woff2|ttf|eot)$/)\n  ) {\n    // Fonts - Cache first\n    event.respondWith(handleFontRequest(request));\n  } else if (\n    request.destination === 'script' ||\n    request.destination === 'style'\n  ) {\n    // Scripts and styles - Cache first\n    event.respondWith(handleStaticRequest(request));\n  } else {\n    // Default - Network first\n    event.respondWith(fetch(request));\n  }\n});\n\n// Handle HTML page requests (Network First)\nasync function handlePageRequest(request) {\n  try {\n    // Try network first\n    const networkResponse = await fetch(request);\n    if (networkResponse.ok) {\n      // Update cache with fresh response\n      const cache = await caches.open(CACHE_NAME);\n      cache.put(request, networkResponse.clone());\n      return networkResponse;\n    }\n  } catch (error) {\n    console.warn(\n      '[Service Worker] Network failed, trying cache for:',\n      request.url\n    );\n  }\n\n  // Fallback to cache\n  const cachedResponse = await caches.match(request);\n  if (cachedResponse) {\n    return cachedResponse;\n  }\n\n  // Ultimate fallback - offline page\n  return (\n    caches.match('/offline.html') ||\n    new Response('<h1>Offline</h1><p>This page is not available offline.</p>', {\n      headers: { 'Content-Type': 'text/html' },\n    })\n  );\n}\n\n// Handle image requests (Cache First)\nasync function handleImageRequest(request) {\n  // Check cache first\n  const cachedResponse = await caches.match(request);\n  if (cachedResponse) {\n    return cachedResponse;\n  }\n\n  try {\n    // Fetch from network\n    const networkResponse = await fetch(request);\n    if (networkResponse.ok) {\n      // Cache the response\n      const cache = await caches.open(IMAGE_CACHE);\n      cache.put(request, networkResponse.clone());\n    }\n    return networkResponse;\n  } catch (error) {\n    console.warn('[Service Worker] Image fetch failed:', request.url);\n    // Return a placeholder or cached version if available\n    return new Response('', { status: 404 });\n  }\n}\n\n// Handle font requests (Cache First)\nasync function handleFontRequest(request) {\n  // Check cache first\n  const cachedResponse = await caches.match(request);\n  if (cachedResponse) {\n    return cachedResponse;\n  }\n\n  try {\n    // Fetch from network\n    const networkResponse = await fetch(request);\n    if (networkResponse.ok) {\n      // Cache the response\n      const cache = await caches.open(FONT_CACHE);\n      cache.put(request, networkResponse.clone());\n    }\n    return networkResponse;\n  } catch (error) {\n    console.warn('[Service Worker] Font fetch failed:', request.url);\n    return new Response('', { status: 404 });\n  }\n}\n\n// Handle static asset requests (Cache First)\nasync function handleStaticRequest(request) {\n  // Check cache first\n  const cachedResponse = await caches.match(request);\n  if (cachedResponse) {\n    return cachedResponse;\n  }\n\n  try {\n    // Fetch from network\n    const networkResponse = await fetch(request);\n    if (networkResponse.ok) {\n      // Cache the response\n      const cache = await caches.open(STATIC_CACHE);\n      cache.put(request, networkResponse.clone());\n    }\n    return networkResponse;\n  } catch (error) {\n    console.warn('[Service Worker] Static asset fetch failed:', request.url);\n    return new Response('', { status: 404 });\n  }\n}\n\n// Handle messages from the main thread\nself.addEventListener('message', event => {\n  if (event.data && event.data.type === 'SKIP_WAITING') {\n    self.skipWaiting();\n  }\n});\n\n// Background sync for analytics (if supported)\nif (\n  'serviceWorker' in navigator &&\n  'sync' in window.ServiceWorkerRegistration.prototype\n) {\n  self.addEventListener('sync', event => {\n    if (event.tag === 'background-sync-analytics') {\n      event.waitUntil(syncAnalyticsData());\n    }\n  });\n}\n\nfunction syncAnalyticsData() {\n  // Implementation for syncing queued analytics data\n  console.warn('[Service Worker] Syncing analytics data');\n  // This would typically send queued analytics events to your server\n}\n"],"names":["CACHE_NAME","STATIC_CACHE","IMAGE_CACHE","FONT_CACHE","STATIC_ASSETS","handlePageRequest","request","networkResponse","fetch","ok","cache","caches","open","put","clone","error","console","warn","url","cachedResponse","match","Response","headers","handleImageRequest","status","handleFontRequest","handleStaticRequest","syncAnalyticsData","self","addEventListener","event","waitUntil","then","addAll","skipWaiting","catch","keys","cacheNames","Promise","all","map","cacheName","startsWith","delete","clients","claim","URL","method","origin","includes","location","destination","respondWith","pathname","data","type","navigator","window","ServiceWorkerRegistration","prototype","tag"],"version":3,"file":"service-worker.js.map"}